<!--
 
    Copyright (C) 2003, 
    Department of Computer Science, University of Tromsoe, Norway.
 
    For distribution policy, see the accompanying file COPYING.
 
 Filename:      los0.html
 Description:   
 Author:        Frode Vatvedt Fjeld <frodef@acm.org>
 Created at:    Wed Nov  5 09:55:54 2003
                
 $Id: movitz.html,v 1.1 2004/01/13 11:05:01 ffjeld Exp $
                
-->

<html>
<head>
<title>Movitz: A Common Lisp OS development platform</title>
</head>
<body>
<h1>Movitz: A Common Lisp OS development platform</h1>
<tt>$Id: movitz.html,v 1.1 2004/01/13 11:05:01 ffjeld Exp $</tt>

<h2><a href="files/">Files</a></h2>
<p> The latest <a href="files/los0.img"> los0 kernel image</a> and its
associated <a href="files/ChangeLog">change-log</a> and <a
href="files/COPYING">copying license</a> can be found here. And there
is the <a href="files/movitz.pdf">current technical documentation</a>.

<p> I'd be interested in receiving reports of crashes, and preferably
reproducible ones. I know there are issues with non-US AT
keyboards. If you have keyboard trouble, you might be able to solve it
by saying <tt>:mapkey code</tt> where code is the ASCII value of the
character you want some key to be mapped to.

<p> If the built-in bootloader of los0.img doesn't work (x86
bootloading is a complicated business, apparently), please try loading
it with <a href="http://www.gnu.org/software/grub/">GRUB</a>. I've
prepared a <a href="files/grub-bootloader.img">GRUB bootloader
image</a> that will load a kernel that is appended to it. That is, you
can prepare a bootable floppy something like this:

<p><pre> cat grub-bootloader.img los0.img >/dev/fd0 </pre>

<h2>Introduction</h2>

<p> The Movitz system aspires to be an implementation of ANSI Common
Lisp that targets the ubiquitous x86 PC architecture "on the
metal". That is, running without any operating system or other form of
software environment. Movitz is a development platform for operating
system kernels, embedded, and single-purpose applications. There can
potentially be several completely different operating systems built
using Movitz.

<p> The Movitz system is two things:
<ul>

<li>A minimal run-time environment which is designed for the x86
architecture running in protected mode. It is minimal in the sense
that all Movitz software can depend on them being present. This is
intended to include the full ANSI Common Lisp specification, as well
as the basic functionality required to perform the chores of typical
operating systems. A particular OS system built with Movitz will
presumably extend this minimal run-time with whatever services it
finds appropriate. This part of Movitz is called <em>Muerte</em>.

<li>A cross-compiler that targets the Muerte run-time. This
cross-compiler is written in plain Common Lisp, and is currently being
developed under Allegro CL, GNU Emacs, and FreeBSD, although (with
minor exceptions) nothing in particular binds it to this platform.
</ul>

<h2>The los0 kernel image</h2>

<p> <a href="files/los0.img">The los0 kernel image</a> is the first
 instance of a Movitz kernel application, or <em>MoKA</em>, and
 contains the current development version of the Muerte. Los0 is a
 very minimal MoKA that is used to drive the development of
 Muerte. This system provides no run-time services beyond a typical
 lisp <a href="http://www.cliki.net/REPL">REPL</a> listener, which may
 be used to interactively peek into your system; be it the lisp system
 per se or the hardware environment. Try <a
 href="http://www.lisp.org/HyperSpec/Body/fun_aproposcm_apropos-list.html"><tt>apropos</tt></a>,
 for example. Some REPL top-level commands (mostly debugging-related)
 are <tt>:bt :pop :restart :trace :untrace :error :help
 :cpu-reset</tt>.

<p> Hardware requirements are approximately: A 386 or better CPU with
slightly more than 2 MB of RAM (the less you have, the sooner you run
out..). The image file can be booted as a floppy image with a PC
emulator like <a href="http://bochs.sf.net">Bochs</a>, VMware, or
VirtualPC, as an actual floppy on a real machine (just <tt>cat</tt>
the image file to the floppy device), or using GRUB or another <a
href="http://www.mcc.ac.uk/Documentation/grub/multiboot.html#SEC_Top">Multiboot</a>
compliant bootloader.

<h2>Status</h2>

<h3>The compiler</h3>

The cross-compiler is fairly complete in terms of the basic mechanisms
required by ANSI CL. However there are most likely bugs to be weeded
out in the more exotic corners of it, like dynamic control-transfers
and the like.

In terms of code quality, in my opinion the compiler produces code
that is reasonable yet far from "great". It is particularly lacking in
the type-inference department. However, the machine-code produced
tends to be shorter than any other x86 Common Lisp compilers I've
compared it to.

<h3>ANSI Common Lisp</h3>

ANSI Common Lisp specifies a quite extensive set of functions, macros,
and types, and these are not all implemented yet. But many are, and in
general my mode of working is to write what to me is "natural" Common
Lisp, and if some operator is not implemented in Muerte, I will
implement it rather than avoid it.

<a href="http://www.cliki.net/CLOS">CLOS</a> and quite a bit of <a
href="http://www.cliki.net/MOP">MOP</a> is supported in the
cross-compiler. At run-time the support is weaker in the sense that
there is for example no facilities for defining new classes or methods
on-the fly. But the introspection is there, and <tt>make-instance</tt>
and other generic functions will do what they are supposed to do.

<h3>Muerte</h3>

Aside from the ANSI Common Lisp library, Muerte consists of functions
to manipulate the CPU and other hardware. There are primitive
accessors like <tt>x86:io-port</tt>, <tt>x86:memref</tt> and
<tt>x86:memref-int</tt>, <tt>x86:eflags</tt>,
<tt>x86:control-register-hi20/lo12</tt>,
<tt>x86:segment-register</tt>, <tt>x86:cpu-id</tt>, and
<tt>x86:read-time-stamp-counter</tt>. CPU introspection is facilitated
with <tt>x86:cpu-signature</tt> and
<tt>x86:find-cpu-features</tt>. All in all, most basic functionality
required to interface any hardware without resorting to inline
assembly is either in place or can easily be added.

<h3>Garbage Collection</h3>

There is no garbage collection scheme implemented yet. Whether a fully
operational GC <em>can</em> be part of Muerte, or whether it requires
extensive support from the particular MoKA run-time, remains to be
seen.

I expect that it turns out that some middle ground must be found: The
basic mechanisms and hooks needed to perform GC will be provided by
Muerte, and the MoKA uses this to provide full GC service (if it will
provide GC at all). In this spirit, I hope to add something like a
simple stop-and-copy GC to los0 soon.


<h2>About OS design in Common Lisp</h2>

Unlike the previous sections, this section is more or less loose
thoughts about what <em>will</em> be rather than describing an
existing system.

<h3>Layering</h3>

I expect Movitz software modules to be categorized broadly as follows:

<dl>

<dt><b>Muerte level</b><dd> This is lower-level functionality that
depend solely on Muerte services. The idea at this level is to provide
a very thin abstraction over the hardware, just enough to make it
convenient to work with in lisp. This means a functional, stateless
interface that makes as few assumptions about how it will be used as
possible. At this level, "functional" (meaning free of side-effects)
applies in a very strong sense, such that e.g. consing must be kept to
an absolute minimum, and when consing can occur must be
predictable. For example, make no assumptions about whether a hardware
device will be used in interrupt-driven or polled mode. The idea is
that modules at this level facilitate exploratory programming, and
also it can be common to every MoKA.

<dt><b>MoKA level</b><dd> This software utilizes the Muerte-level
modules to build 3D desktop AI-enabled operating systems and the like.

</dl>

<address>
<a href="mailto:frodef+los@cs.uit.no">Frode Vatvedt Fjeld</a>
</address>
</body>
</html>