;;;;------------------------------------------------------------------
;;;; 
;;;;    Copyright (C) 2001-2004, 
;;;;    Department of Computer Science, University of Tromso, Norway.
;;;; 
;;;;    For distribution policy, see the accompanying file COPYING.
;;;; 
;;;; Filename:      memref.lisp
;;;; Description:   Low-level memory access.
;;;; Author:        Frode Vatvedt Fjeld <frodef@acm.org>
;;;; Created at:    Tue Mar  6 21:25:49 2001
;;;;                
;;;; $Id: memref.lisp,v 1.31 2004/10/07 12:43:29 ffjeld Exp $
;;;;                
;;;;------------------------------------------------------------------

(provide :muerte/memref)

(in-package muerte)

(define-compiler-macro memref (&whole form object offset index type &key (localp nil) (endian :host)
			       &environment env)
  (if (or (not (movitz:movitz-constantp type env))
	  (not (movitz:movitz-constantp localp env))
	  (not (movitz:movitz-constantp endian env)))
      form
    (labels ((sub-extract-constant-delta (form)
	       "Try to extract at compile-time an integer offset from form."
	       (cond
		((movitz:movitz-constantp form env)
		 (let ((x (movitz:movitz-eval form env)))
		   (check-type x integer)
		   (values x 0)))
		((not (consp form))
		 (values 0 form))
		(t (case (car form)
		     (1+ (values 1 (second form)))
		     (1- (values -1 (second form)))
		     (+ (case (length form)
			  (1 (values 0 0))
			  (2 (values 0 (second form)))
			  (t (loop with x = 0 and f = nil for sub-form in (cdr form)
				 as sub-value = (when (movitz:movitz-constantp sub-form env)
						  (movitz:movitz-eval sub-form env))
				 do (if (integerp sub-value)
					(incf x sub-value)
				      (push sub-form f))
				 finally (return (values x (cons '+ (nreverse f))))))))
		     (t #+ignore (warn "extract from: ~S" form)
			(values 0 form))))))
	     (extract-constant-delta (form)
	       "Try to extract at compile-time an integer offset from form, repeatedly."
	       (multiple-value-bind (constant-term variable-term)
		   (sub-extract-constant-delta form)
		 (if (= 0 constant-term)
		     (values 0 variable-term)
		   (multiple-value-bind (sub-constant-term sub-variable-term)
		       (extract-constant-delta variable-term)
		     (values (+ constant-term sub-constant-term)
			     sub-variable-term))))))
      (multiple-value-bind (constant-index index)
	  (extract-constant-delta index)
	(multiple-value-bind (constant-offset offset)
	    (extract-constant-delta offset)
	  (flet ((offset-by (element-size)
		   (+ constant-offset (* constant-index element-size))))
	    #+ignore
	    (warn "o: ~S, co: ~S, i: ~S, ci: ~S"
		  offset constant-offset
		  index constant-index)
	    (let ((type (movitz:movitz-eval type env)))
	      (case type
		(:unsigned-byte8
		 (cond
		  ((and (eq 0 offset) (eq 0 index))
		   `(with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 8))
		      (:compile-form (:result-mode :eax) ,object)
		      (:movzxb (:eax ,(offset-by 1)) :ecx)))
		  ((eq 0 offset)
		   `(with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 8))
		      (:compile-two-forms (:eax :untagged-fixnum-ecx) ,object ,index)
		      (:movzxb (:eax :ecx ,(offset-by 1)) :ecx)))
		  (t (let ((object-var (gensym "memref-object-")))
		       `(let ((,object-var ,object))
			  (with-inline-assembly (:returns :untagged-fixnum-ecx :type (unsigned-byte 8))
			    (:compile-two-forms (:ecx :ebx) ,offset ,index)
			    (:load-lexical (:lexical-binding ,object-var) :eax)
			    (:addl :ebx :ecx) ; index += offset
			    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			    (:movzxb (:eax :ecx ,(offset-by 1)) :ecx)))))))
		(:unsigned-byte16
		 (let* ((endian (ecase (movitz:movitz-eval endian env)
				  ((:host :little) :little)
				  (:big :big)))
			(endian-fix-ecx (ecase endian
					  (:little nil)
					  (:big `((:xchgb :cl :ch))))))
		   (cond
		    ((and (eq 0 offset) (eq 0 index))
		     `(with-inline-assembly (:returns :untagged-fixnum-ecx)
			(:compile-form (:result-mode :eax) ,object)
			(:movzxw (:eax ,(offset-by 2)) :ecx)
			,@endian-fix-ecx))
		    ((eq 0 offset)
		     (let ((object-var (gensym "memref-object-"))
			   (index-var (gensym "memref-index-")))
		       `(let ((,object-var ,object)
			      (,index-var ,index))
			  (with-inline-assembly (:returns :untagged-fixnum-ecx)
			    (:compile-two-forms (:eax :ecx) ,object-var ,index-var)
			    (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
			    (:movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			    ,@endian-fix-ecx))))
		    (t (let ((object-var (gensym "memref-object-"))
			     (offset-var (gensym "memref-offset-"))
			     (index-var (gensym "memref-index-")))
			 `(let ((,object-var ,object)
				(,offset-var ,offset)
				(,index-var ,index))
			    (with-inline-assembly (:returns :untagged-fixnum-ecx)
			      (:compile-two-forms (:ecx :ebx) ,offset-var ,index-var)
			      (:leal (:ecx (:ebx 2)) :ecx)
			      (:load-lexical (:lexical-binding ,object-var) :eax)
			      (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			      (:movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			      ,@endian-fix-ecx)))))))
		(:unsigned-byte14
		 (cond
		  ((and (eq 0 offset) (eq 0 index))
		   `(with-inline-assembly (:returns :ecx :type (unsigned-byte 14))
		      (:compile-form (:result-mode :eax) ,object)
		      (:movzxw (:eax ,(offset-by 2)) :ecx)
		      (:testb ,movitz:+movitz-fixnum-zmask+ :cl)
		      (:jnz '(:sub-program () (:int 63)))))
		  ((eq 0 offset)
		   (let ((object-var (gensym "memref-object-"))
			 (index-var (gensym "memref-index-")))
		     `(let ((,object-var ,object)
			    (,index-var ,index))
			(with-inline-assembly (:returns :ecx)
			  (:compile-two-forms (:eax :ecx) ,object-var ,index-var)
			  (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
			  (:movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			  (:testb ,movitz:+movitz-fixnum-zmask+ :cl)
			  (:jnz '(:sub-program () (:int 63)))))))
		  (t (let ((object-var (gensym "memref-object-"))
			   (offset-var (gensym "memref-offset-"))
			   (index-var (gensym "memref-index-")))
		       `(let ((,object-var ,object)
			      (,offset-var ,offset)
			      (,index-var ,index))
			  (with-inline-assembly (:returns :ecx)
			    (:compile-two-forms (:ecx :ebx) ,offset-var ,index-var)
			    (:leal (:ecx (:ebx 2)) :ecx)
			    (:load-lexical (:lexical-binding ,object-var) :eax)
			    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			    (:movzxw (:eax :ecx ,(offset-by 2)) :ecx)
			    (:testb ,movitz:+movitz-fixnum-shift+ :cl)
			    (:jnz '(:sub-program () (:int 63)))))))))
		(:unsigned-byte29+3
		 ;; Two values: the 29 upper bits as unsigned integer,
		 ;; and secondly the lower 3 bits as unsigned.
		 (assert (= 2 movitz::+movitz-fixnum-shift+))
		 `(with-inline-assembly (:returns :multiple-values)
		    (:compile-form (:result-mode :push) ,object)
		    (:compile-two-forms (:ecx :ebx) ,offset ,index)
		    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
		    (:addl :ebx :ecx)
		    (:popl :eax)	; object
		    (:movl (:eax :ecx ,(offset-by 4)) :ecx)
		    (:leal ((:ecx 4)) :ebx)
		    (:shrl 1 :ecx)
		    (:andl #b11100 :ebx)
		    (:andl -4 :ecx)
		    (:movl :ecx :eax)
		    (:movl 2 :ecx)
		    (:stc)))
		(:signed-byte30+2
		 ;; Two values: the 30 upper bits as signed integer,
		 ;; and secondly the lower 2 bits as unsigned.
		 (assert (= 2 movitz::+movitz-fixnum-shift+))
		 `(with-inline-assembly (:returns :multiple-values)
		    (:compile-form (:result-mode :push) ,object)
		    (:compile-two-forms (:ecx :ebx) ,offset ,index)
		    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
		    (:addl :ebx :ecx)
		    (:popl :eax)	; object
		    (:movl (:eax :ecx ,(offset-by 4)) :ecx)
		    (:leal ((:ecx 4)) :ebx)
		    (:andl #b1100 :ebx)
		    (:andl -4 :ecx)
		    (:movl :ecx :eax)
		    (:movl 2 :ecx)
		    (:stc)))
		(:character
		 (when (eq 0 index) (warn "memref zero char index!"))
		 (cond
		  ((eq 0 offset)
		   `(with-inline-assembly (:returns :eax)
		      (:compile-two-forms (:ebx :ecx) ,object ,index)
		      (:xorl :eax :eax)
		      (:movb ,(movitz:tag :character) :al)
		      (:sarl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale index
		      (:movb (:ebx :ecx ,(offset-by 1)) :ah)))
		  (t (let ((object-var (gensym "memref-object-")))
		       `(let ((,object-var ,object))
			  (with-inline-assembly (:returns :eax)
			    (:compile-two-forms (:ecx :ebx) ,offset ,index)
			    (:addl :ebx :ecx)
			    (:xorl :eax :eax)
			    (:movb ,(movitz:tag :character) :al)
			    (:load-lexical (:lexical-binding ,object-var) :ebx)
			    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale offset+index
			    (:movb (:ebx :ecx ,(offset-by 1)) :ah)))))))
		(:location
		 (assert (= 4 movitz::+movitz-fixnum-factor+))
		 (cond
		  ((and (eq 0 offset) (eq 0 index))
		   `(with-inline-assembly (:returns :ecx)
		      (:compile-form (:result-mode :eax) ,object)
		      (:movl (:eax ,(offset-by 4)) :ecx)
		      (:andl -4 :ecx)))
		  ((eq 0 offset)
		   `(with-inline-assembly (:returns :ecx)
		      (:compile-two-forms (:eax :ecx) ,object ,index)
		      (:movl (:eax :ecx ,(offset-by 4)) :ecx)
		      (:andl -4 :ecx)))
		  (t (let ((object-var (gensym "memref-object-")))
		       `(let ((,object-var ,object))
			  (with-inline-assembly (:returns :ecx)
			    (:compile-two-forms (:ecx :ebx) ,offset ,index)
			    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			    (:load-lexical (:lexical-binding ,object-var) :eax)
			    (:addl :ebx :ecx)
			    (:movl (:eax :ecx ,(offset-by 4)) :ecx)
			    (:andl -4 :ecx)))))))
		(:unsigned-byte32
		 (let ((endian (movitz:movitz-eval endian env)))
		   (assert (member endian '(:host :little))))
		 (assert (= 4 movitz::+movitz-fixnum-factor+))
		 (cond
		  ((and (eq 0 offset) (eq 0 index))
		   `(with-inline-assembly (:returns :untagged-fixnum-ecx)
		      (:compile-form (:result-mode :eax) ,object)
		      (:movl (:eax ,(offset-by 4)) :ecx)))
		  ((eq 0 offset)
		   `(with-inline-assembly (:returns :untagged-fixnum-ecx)
		      (:compile-two-forms (:eax :ecx) ,object ,index)
		      (:movl (:eax :ecx ,(offset-by 4)) :ecx)))
		  (t (let ((object-var (gensym "memref-object-")))
		       `(let ((,object-var ,object))
			  (with-inline-assembly (:returns :untagged-fixnum-ecx)
			    (:compile-two-forms (:ecx :ebx) ,offset ,index)
			    (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
			    (:load-lexical (:lexical-binding ,object-var) :eax)
			    (:addl :ebx :ecx)
			    (:movl (:eax :ecx ,(offset-by 4)) :ecx)))))))
		(:lisp
		 (let* ((localp (movitz:movitz-eval localp env))
			(prefixes (if localp
				      nil
				    movitz:*compiler-nonlocal-lispval-read-segment-prefix*)))
		   (cond
		    ((and (eql 0 index) (eql 0 offset))
		     `(with-inline-assembly (:returns :register)
			(:compile-form (:result-mode :register) ,object)
			(,prefixes :movl ((:result-register) ,(offset-by 4)) (:result-register))))
		    ((eql 0 offset)
		     `(with-inline-assembly (:returns :eax)
			(:compile-two-forms (:eax :ecx) ,object ,index)
			,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
			    `((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ecx))
			(,prefixes :movl (:eax :ecx ,(offset-by 4)) :eax)))
		    ((eql 0 index)
		     `(with-inline-assembly (:returns :eax)
			(:compile-two-forms (:eax :untagged-fixnum-ecx) ,object ,offset)
			(,prefixes :movl (:eax :ecx ,(offset-by 4)) :eax)))
		    (t (assert (not (movitz:movitz-constantp offset env)))
		       (assert (not (movitz:movitz-constantp index env)))
		       (let ((object-var (gensym "memref-object-")))
			 (assert (= 4 movitz:+movitz-fixnum-factor+))
			 `(let ((,object-var ,object))
			    (with-inline-assembly (:returns :eax)
			      (:compile-two-forms (:ecx :ebx) ,offset ,index)
			      (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			      (:load-lexical (:lexical-binding ,object-var) :eax)
			      (:addl :ebx :ecx)
			      (,prefixes :movl (:eax :ecx ,(offset-by 4)) :eax))))))))
		(:code-vector
		 ;; A code-vector is like a normal lisp word pointer,
		 ;; except it's known to point to a code-vector, and
		 ;; the pointer value is offset by 2. The trick is to
		 ;; perform this pointer arithmetics while never
		 ;; keeping a non-lisp-word pointer in a register.
		 (cond
		  ((and (eql 0 index) (eql 0 offset))
		   `(with-inline-assembly (:returns :eax)
		      (:compile-form (:result-mode :ebx) ,object)
		      (:movl ,(ldb (byte 32 0) (- movitz:+code-vector-word-offset+)) :eax)
		      (:addl (:ebx ,(offset-by 4)) :eax)))
		  ((eql 0 offset)
		   `(with-inline-assembly (:returns :eax)
		      (:compile-two-forms (:ebx :ecx) ,object ,index)
		      ,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
			  `((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ecx))
		      (:movl ,(ldb (byte 32 0) (- movitz:+code-vector-word-offset+)) :eax)
		      (:addl (:ebx :ecx ,(offset-by 4)) :eax)))
		  ((eql 0 index)
		   `(with-inline-assembly (:returns :eax)
		      (:compile-two-forms (:ebx :untagged-fixnum-ecx) ,object ,offset)
		      (:movl ,(ldb (byte 32 0) (- movitz:+code-vector-word-offset+)) :eax)
		      (:addl (:ebx :ecx ,(offset-by 4)) :eax)))
		  (t (error "variable memref type :code-vector not implemented."))
		  #+ignore
		  (t (assert (not (movitz:movitz-constantp offset env)))
		     (assert (not (movitz:movitz-constantp index env)))
		     (let ((object-var (gensym "memref-object-")))
		       (assert (= 4 movitz:+movitz-fixnum-factor+))
		       `(let ((,object-var ,object))
			  (with-inline-assembly (:returns :eax)
			    (:compile-two-forms (:ecx :ebx) ,offset ,index)
			    (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			    (:load-lexical (:lexical-binding ,object-var) :eax)
			    (:addl :ebx :ecx)
			    (:movl (:eax :ecx ,(offset-by 4)) :eax)))))))
		(t (error "Unknown memref type: ~S" (movitz::eval-form type nil nil))
		   form)))))))))

(defun memref (object offset index type &key localp (endian :host))
  (ecase type
    (:lisp              (if localp
			    (memref object offset index :lisp :localp t)
			  (memref object offset index :lisp :localp nil)))
    (:unsigned-byte32   (memref object offset index :unsigned-byte32))
    (:character         (memref object offset index :character))
    (:unsigned-byte8    (memref object offset index :unsigned-byte8))
    (:location          (memref object offset index :location))
    (:unsigned-byte14   (memref object offset index :unsigned-byte14))
    (:unsigned-byte16   (ecase endian
			  ((:host :little)
			   (memref object offset index :unsigned-byte16 :endian :little))
			  ((:big)
			   (memref object offset index :unsigned-byte16 :endian :big))))
    (:signed-byte30+2   (memref object offset index :signed-byte30+2))
    (:unsigned-byte29+3 (memref object offset index :unsigned-byte29+3))))

(define-compiler-macro (setf memref) (&whole form &environment env value object offset index type
				      &key (localp nil) (endian :host))
  (if (or (not (movitz:movitz-constantp type env))
	  (not (movitz:movitz-constantp localp env))
	  (not (movitz:movitz-constantp endian env)))
      form
    (case (movitz::eval-form type)
      (:character
       (cond
	((and (movitz:movitz-constantp value env)
	      (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp index env))
	 (let ((value (movitz:movitz-eval value env)))
	   (check-type value movitz::movitz-character)
	   `(progn
	      (with-inline-assembly (:returns :nothing)
		(:compile-form (:result-mode :ebx) ,object)
		(:movb ,(movitz:movitz-intern value)
		       (:ebx ,(+ (movitz:movitz-eval offset env)
				 (* 1 (movitz:movitz-eval index env))))))
	      ,value)))
	((and (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp index env))
	 `(with-inline-assembly (:returns :eax)
	    (:compile-two-forms (:eax :ebx) ,value ,object)
	    (:movb :ah (:ebx ,(+ (movitz:movitz-eval offset env)
				 (* 1 (movitz:movitz-eval index env)))))))
	((movitz:movitz-constantp offset env)
	 (let ((value-var (gensym "memref-value-")))
	   `(let ((,value-var ,value)) 
	      (with-inline-assembly (:returns :eax)
		(:compile-two-forms (:ebx :untagged-fixnum-ecx) ,object ,index)
		(:load-lexical (:lexical-binding ,value-var) :eax)
		(:movb :ah (:ebx :ecx ,(+ (movitz:movitz-eval offset env))))))))
	(t (let ((object-var (gensym "memref-object-"))
		 (offset-var (gensym "memref-offset-")))
	     `(let ((,object-var ,object) (,offset-var ,offset))
		(with-inline-assembly (:returns :nothing)
		  (:compile-two-forms (:ecx :eax) ,index ,value)
		  (:load-lexical (:lexical-binding ,offset-var) :ebx)
		  (:addl :ebx :ecx)
		  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
		  (:load-lexical (:lexical-binding ,object-var) :ebx)
		  (:movb :ah (:ebx :ecx))))))))
      (:unsigned-byte32
       (let ((endian (movitz:movitz-eval endian env)))
	 (assert (member endian '(:host :little))))
       (assert (= 4 movitz::+movitz-fixnum-factor+))
       (cond
	((and (movitz:movitz-constantp value env)
	      (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp index env))
	 (let ((value (movitz:movitz-eval value env)))
	   (check-type value (unsigned-byte 32))
	   `(progn
	      (with-inline-assembly (:returns :nothing)
		(:compile-form (:result-mode :ebx) ,object)
		(:movl ,value (:ebx ,(+ (movitz:movitz-eval offset env)
					(* 4 (movitz:movitz-eval index env))))))
	      ,value)))
	((and (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp index env))
	 `(with-inline-assembly (:returns :untagged-fixnum-ecx)
	    (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,value ,object)
	    (:movl :ecx (:ebx ,(+ (movitz:movitz-eval offset env)
				  (* 4 (movitz:movitz-eval index env)))))))
	((and (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp value env))
	 (let ((value (movitz:movitz-eval value env)))
	   (check-type value (unsigned-byte 32))
	   `(progn
	      (with-inline-assembly (:returns :nothing)
		(:compile-two-forms (:ecx :ebx) ,index ,object)
		(:movl ,value (:ebx :ecx ,(movitz:movitz-eval offset env))))
	      ,value)))
	((movitz:movitz-constantp offset env)
	 (let ((value-var (gensym "memref-value-"))
	       (object-var (gensym "memref-object-"))
	       (index-var (gensym "memref-index-")))
	   `(let ((,value-var ,value)
		  (,object-var ,object)
		  (,index-var ,index))
	      (with-inline-assembly (:returns :untagged-fixnum-ecx)
		(:load-lexical (:lexical-binding ,value-var) :untagged-fixnum-ecx)
		(:compile-two-forms (:ebx :eax) ,object-var ,index-var)
		(:movl :ecx (:eax :ebx ,(movitz:movitz-eval offset env)))))))
	(t (let ((value-var (gensym "memref-value-"))
		 (object-var (gensym "memref-object-"))
		 (offset-var (gensym "memref-offset-"))
		 (index-var (gensym "memref-index-")))
	     (assert (= 4 movitz:+movitz-fixnum-factor+))
	     `(let ((,value-var ,value)
		    (,object-var ,object)
		    (,offset-var ,offset)
		    (,index-var ,index))
		(with-inline-assembly (:returns :untagged-fixnum-ecx)
		  (:load-lexical (:lexical-binding ,value-var) :eax)
		  (:call-global-pf unbox-u32)
		  (:compile-two-forms (:eax :edx) ,index-var ,offset-var)
		  (:load-lexical (:lexical-binding ,object-var) :ebx)
		  (:std)
		  (:sarl ,movitz::+movitz-fixnum-shift+ :edx)
		  (:addl :eax :edx) ; EDX = offset+index
		  (:movl :ecx (:ebx :edx))
		  (:movl :edi :edx)
		  (:cld)))))))
      (:unsigned-byte16
       (let ((endian (ecase (movitz:movitz-eval endian env)
		       ((:host :little) :little)
		       (:big :big))))
	 (cond
	  ((and (movitz:movitz-constantp value env)
		(movitz:movitz-constantp offset env)
		(movitz:movitz-constantp index env))
	   (let* ((host-value (movitz:movitz-eval value env))
		  (value (ecase endian
			   (:little host-value)
			   (:big (dpb (ldb (byte 8 0) host-value)
				      (byte 8 8)
				      (ldb (byte 8 8) host-value))))))
	     (check-type value (unsigned-byte 16))
	     `(progn
		(with-inline-assembly (:returns :nothing)
		  (:compile-form (:result-mode :ebx) ,object)
		  (:movw ,value (:ebx ,(+ (movitz:movitz-eval offset env)
					  (* 2 (movitz:movitz-eval index env))))))
		,value)))
	  ((and (movitz:movitz-constantp offset env)
		(movitz:movitz-constantp index env))
	   `(with-inline-assembly (:returns :untagged-fixnum-ecx)
	      (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,value ,object)
	      ,@(ecase endian
		  (:little nil)
		  (:big `((:xchg :cl :ch))))
	      (:movw :cx (:ebx ,(+ (movitz:movitz-eval offset env)
				   (* 2 (movitz:movitz-eval index env)))))))
	  ((and (movitz:movitz-constantp offset env)
		(movitz:movitz-constantp value env))
	   (let ((value (movitz:movitz-eval value env))
		 (index-var (gensym "memref-index-"))
		 (object-var (gensym "memref-object-")))
	     (check-type value (unsigned-byte 16))
	     `(let ((,object-var ,object)
		    (,index-var ,index))
		(with-inline-assembly (:returns :nothing)
		  (:compile-two-forms (:ecx :ebx) ,index-var ,object-var)
		  (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
		  (:movw ,value (:ebx :ecx ,(movitz:movitz-eval offset env))))
		,value)))
	  ((movitz:movitz-constantp offset env)
	   (let ((value-var (gensym "memref-value-"))
		 (index-var (gensym "memref-index-"))
		 (object-var (gensym "memref-object-")))
	     (if (<= 16 movitz:*compiler-allow-untagged-word-bits*)
		 `(let ((,value-var ,value)
			(,object-var ,object)
			(,index-var ,index))
		    (with-inline-assembly (:returns :untagged-fixnum-eax)
		      (:compile-two-forms (:ebx :ecx) ,object-var ,index-var)
		      (:load-lexical (:lexical-binding ,value-var) :untagged-fixnum-eax)
		      (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
		      (:movw :ax (:ebx :ecx  ,(movitz:movitz-eval offset env)))))
	       `(let ((,value-var ,value)
		      (,object-var ,object)
		      (,index-var ,index))
		  (with-inline-assembly (:returns :nothing)
		    (:compile-two-forms (:ebx :ecx) ,object-var ,index-var)
		    (:load-lexical (:lexical-binding ,value-var) :eax)
		    (:sarl ,(1- movitz:+movitz-fixnum-shift+) :ecx)
		    (:movl :edi :edx)
		    (:std)
		    (:shrl ,movitz:+movitz-fixnum-shift+ :eax)
		    ,@(ecase endian
			(:little nil)
			(:big `((:xchgb :al :ah))))
		    (:movw :ax (:ebx :ecx ,(movitz:movitz-eval offset env)))
		    (:movl :edi :eax)
		    (:cld))
		  ,value-var))))
	  (t (let ((value-var (gensym "memref-value-"))
		   (object-var (gensym "memref-object-"))
		   (offset-var (gensym "memref-offset-"))
		   (index-var (gensym "memref-index-")))
	       (if (<= 16 movitz:*compiler-allow-untagged-word-bits*)
		   `(let ((,value-var ,value)
			  (,object-var ,object)
			  (,offset-var ,offset)
			  (,index-var ,index))
		      (with-inline-assembly (:returns :untagged-fixnum-eax)
			(:compile-two-forms (:ebx :ecx) ,offset-var ,index-var)
			(:load-lexical (:lexical-binding ,value-var) :eax)
			(:andl ,(* movitz:+movitz-fixnum-factor+ #xffff) :eax)
			(:leal (:ebx (:ecx 2)) :ecx)
			(:shrl ,movitz:+movitz-fixnum-shift+ :eax)
			(:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
			(:load-lexical (:lexical-binding ,object-var) :ebx)
			(:movw :ax (:ebx :ecx))))
		 `(let ((,value-var ,value)
			(,object-var ,object)
			(,offset-var ,offset)
			(,index-var ,index))
		    (with-inline-assembly (:returns :nothing)
		      (:compile-two-forms (:ebx :ecx) ,offset-var ,index-var)
		      (:load-lexical (:lexical-binding ,value-var) :eax)
		      (:leal (:ebx (:ecx 2)) :ecx)
		      (:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
		      (:load-lexical (:lexical-binding ,object-var) :ebx)
		      (:std)
		      (:shrl ,movitz:+movitz-fixnum-shift+ :eax)
		      ,@(ecase endian
			  (:little nil)
			  (:big `((:xchgb :al :ah))))
		      (:movw :ax (:ebx :ecx))
		      (:shll ,movitz:+movitz-fixnum-shift+ :eax)
		      (:movl :edi :edx)
		      (:cld))
		    ,value-var)))))))
      (:unsigned-byte8
       (cond
	((and (movitz:movitz-constantp value env)
	      (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp index env))
	 (let ((value (movitz:movitz-eval value env)))
	   (check-type value (unsigned-byte 8))
	   `(progn
	      (with-inline-assembly (:returns :nothing)
		(:compile-form (:result-mode :ebx) ,object)
		(:movb ,value (:ebx ,(+ (movitz:movitz-eval offset env)
					(* 1 (movitz:movitz-eval index env))))))
	      ,value)))
	((and (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp index env))
	 `(with-inline-assembly (:returns :untagged-fixnum-ecx)
	    (:compile-two-forms (:ecx :ebx) ,value ,object)
	    (:shrl ,movitz:+movitz-fixnum-shift+ :ecx)
	    (:movb :cl (:ebx ,(+ (movitz:movitz-eval offset env)
				 (* 1 (movitz:movitz-eval index env)))))))
	((and (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp value env))
	 (let ((value (movitz:movitz-eval value env)))
	   (check-type value (unsigned-byte 8))
	   `(progn
	      (with-inline-assembly (:returns :untagged-fixnum-ecx)
		(:compile-two-forms (:eax :ecx) ,object ,index)
		(:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
		(:movb ,value (:eax :ecx ,(movitz:movitz-eval offset env))))
	      value)))
	((movitz:movitz-constantp offset env)
	 (let ((value-var (gensym "memref-value-")))
	   `(let ((,value-var ,value))
	      (with-inline-assembly (:returns :nothing)
		(:compile-two-forms (:ebx :ecx) ,object ,index)
		(:load-lexical (:lexical-binding ,value-var) :eax)
		(:sarl ,movitz:+movitz-fixnum-shift+ :ecx)
		(:shll ,(- 8 movitz:+movitz-fixnum-shift+) :eax) ; value into :AH
		(:movb :ah (:ebx :ecx ,(movitz:movitz-eval offset env))))
	      ,value-var)))
	(t (let ((value-var (gensym "memref-value-"))
		 (object-var (gensym "memref-object-")))
	     `(let ((,value-var ,value) (,object-var ,object))
		(with-inline-assembly (:returns :nothing)
		  (:compile-two-forms (:ebx :ecx) ,offset ,index)
		  (:load-lexical (:lexical-binding ,value-var) :eax)
		  (:addl :ebx :ecx)
		  (:load-lexical (:lexical-binding ,object-var) :ebx) ; value into :AH
		  (:shll ,(- 8 movitz:+movitz-fixnum-shift+) :eax)
		  (:sarl ,movitz::+movitz-fixnum-shift+ :ecx)
		  (:movb :ah (:ebx :ecx)))
		,value-var)))))
      (:lisp
       (let* ((localp (movitz:movitz-eval localp env))
	      (prefixes (if localp
			    nil
			  movitz:*compiler-nonlocal-lispval-write-segment-prefix*)))
	 (cond
	  ((and (movitz:movitz-constantp offset env)
		(movitz:movitz-constantp index env))
	   `(with-inline-assembly (:returns :eax)
	      (:compile-two-forms (:eax :ebx) ,value ,object)
	      (,prefixes :movl :eax (:ebx ,(+ (movitz:movitz-eval offset env)
					      (* 4 (movitz:movitz-eval index env)))))))
	  ((movitz:movitz-constantp offset env)
	   (let ((value-var (gensym "memref-value-")))
	     `(let ((,value-var ,value))
		(with-inline-assembly (:returns :eax)
		  (:compile-two-forms (:ebx :ecx) ,object ,index)
		  (:load-lexical (:lexical-binding ,value-var) :eax)
		  ,@(when (plusp (- movitz:+movitz-fixnum-shift+ 2))
		      `((:sarl ,(- movitz:+movitz-fixnum-shift+ 2)) :ecx))
		  (,prefixes :movl :eax (:ebx :ecx ,(movitz:movitz-eval offset env)))))))
	  (t (let ((value-var (gensym "memref-value-"))
		   (object-var (gensym "memref-object-")))
	       `(let ((,value-var ,value) (,object-var ,object))
		  (with-inline-assembly (:returns :eax)
		    (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,offset ,index)
		    (:load-lexical (:lexical-binding ,value-var) :eax)
		    ,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
			`((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ebx))
		    (:addl :ebx :ecx)	; index += offset
		    (:load-lexical (:lexical-binding ,object-var) :ebx)
		    (,prefixes :movl :eax (:ebx :ecx)))))))))
      (:code-vector
       (cond
	((and (movitz:movitz-constantp offset env)
	      (movitz:movitz-constantp index env))
	 `(with-inline-assembly (:returns :eax)
	    (:compile-two-forms (:eax :ebx) ,value ,object)
	    (:movl ,movitz:+code-vector-word-offset+
		   (:ebx ,(+ (movitz:movitz-eval offset env)
			     (* 4 (movitz:movitz-eval index env)))))
	    (:addl :eax (:ebx ,(+ (movitz:movitz-eval offset env)
				  (* 4 (movitz:movitz-eval index env)))))))
	((movitz:movitz-constantp offset env)
	 (let ((value-var (gensym "memref-value-")))
	   `(let ((,value-var ,value))
	      (with-inline-assembly (:returns :eax)
		(:compile-two-forms (:ebx :ecx) ,object ,index)
		(:load-lexical (:lexical-binding ,value-var) :eax)
		,@(when (plusp (- movitz:+movitz-fixnum-shift+ 2))
		    `((:sarl ,(- movitz:+movitz-fixnum-shift+ 2)) :ecx))
		(:movl ,movitz:+code-vector-word-offset+
		       (:ebx :ecx ,(movitz:movitz-eval offset env)))
		(:addl :eax (:ebx :ecx ,(movitz:movitz-eval offset env)))))))
	(t (error "variable (setf memref) type :code-vector not implemented.")
	   #+ignore
	   (let ((value-var (gensym "memref-value-"))
		 (object-var (gensym "memref-object-")))
	     `(let ((,value-var ,value) (,object-var ,object))
		(with-inline-assembly (:returns :eax)
		  (:compile-two-forms (:untagged-fixnum-ecx :ebx) ,offset ,index)
		  (:load-lexical (:lexical-binding ,value-var) :eax)
		  ,@(when (cl:plusp (cl:- movitz::+movitz-fixnum-shift+ 2))
		      `((:sarl ,(cl:- movitz::+movitz-fixnum-shift+ 2)) :ebx))
		  (:addl :ebx :ecx)	; index += offset
		  (:load-lexical (:lexical-binding ,object-var) :ebx)
		  (:movl :eax (:ebx :ecx))))))))
      (t ;; (warn "Can't handle inline MEMREF: ~S" form)
	 form))))

(defun (setf memref) (value object offset index type &key localp (endian :host))
  (ecase type
    (:character
     (setf (memref object offset index :character) value))
    (:unsigned-byte8
     (setf (memref object offset index :unsigned-byte8) value))
    (:unsigned-byte16
     (ecase endian
       ((:host :little)
	(setf (memref object offset index :unsigned-byte16 :endian :little) value))
       ((:big)
	(setf (memref object offset index :unsigned-byte16 :endian :big) value))))
    (:unsigned-byte32
     (setf (memref object offset index :unsigned-byte32) value))
    (:lisp
     (if localp
	 (setf (memref object offset index :lisp :localp t) value)
       (setf (memref object offset index :lisp :localp nil) value)))))

(define-compiler-macro memref-int (&whole form &environment env address offset index type
				   &optional physicalp)
  (if (or (not (movitz:movitz-constantp type physicalp))
	  (not (movitz:movitz-constantp physicalp env)))
      form
    (let* ((physicalp (movitz::eval-form physicalp env))
	   (prefixes (if (not physicalp)
			 ()
		       movitz:*compiler-physical-segment-prefix*)))
      (ecase (movitz::eval-form type)
	(:lisp
	 (let ((address-var (gensym "memref-int-address-")))
	   `(let ((,address-var ,address))
	      (with-inline-assembly (:returns :eax)
		(:compile-two-forms (:eax :ecx) ,offset ,index)
		(:load-lexical (:lexical-binding ,address-var) :ebx)
		(:shll 2 :ecx)
		(:addl :ebx :eax)
		(:into)
		(:testb ,(mask-field (byte (+ 2 movitz::+movitz-fixnum-shift+) 0) -1)
			:al)
		(:jnz '(:sub-program () (:int 63)))
		(:addl :eax :ecx)
		(:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale down address
		(,prefixes :movl (:ecx) :eax)))))
	(:unsigned-byte32
	 (let ((address-var (gensym "memref-int-address-")))
	   `(let ((,address-var ,address))
	      (with-inline-assembly (:returns :untagged-fixnum-ecx)
		(:compile-two-forms (:eax :ecx) ,offset ,index)
		(:load-lexical (:lexical-binding ,address-var) :ebx)
		(:shll 2 :ecx)
		(:addl :ebx :eax)
		(:into)
		(:testb ,(mask-field (byte (+ 2 movitz::+movitz-fixnum-shift+) 0) -1)
			:al)
		(:jnz '(:sub-program () (:int 63)))
		(:addl :eax :ecx)
		(:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale down address
		(,prefixes :movl (:ecx) :ecx)))))
	(:unsigned-byte8
	 (cond
	  ((and (eq 0 offset) (eq 0 index))
	   `(with-inline-assembly (:returns :untagged-fixnum-ecx)
	      (:compile-form (:result-mode :untagged-fixnum-ecx) ,address)
	      (,prefixes :movzxw (:ecx) :ecx)))
	  (t (let ((address-var (gensym "memref-int-address-")))
	       `(let ((,address-var ,address))
		  (with-inline-assembly (:returns :untagged-fixnum-ecx)
		    (:compile-two-forms (:eax :ecx) ,offset ,index)
		    (:load-lexical (:lexical-binding ,address-var) :ebx)
		    (:addl :eax :ecx)
		    (:addl :ebx :ecx)
		    (:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale down address
		    (,prefixes :movzxw (:ecx) :ecx)))))))
	(:unsigned-byte16
	 (cond
	  ((and (eq 0 offset) (eq 0 index))
	   `(with-inline-assembly (:returns :untagged-fixnum-ecx
					    :type (unsigned-byte 16))
	      (:compile-form (:result-mode :untagged-fixnum-ecx) ,address)
	      (,prefixes :movzxw (:ecx) :ecx)))
	  (t (let ((address-var (gensym "memref-int-address-")))
	       `(let ((,address-var ,address))
		  (with-inline-assembly (:returns :untagged-fixnum-ecx
						  :type (unsigned-byte 16))
		    (:compile-two-forms (:eax :ecx) ,offset ,index)
		    (:load-lexical (:lexical-binding ,address-var) :ebx)
		    (:shll 1 :ecx)	; scale index
		    (:addl :eax :ecx)
		    (:addl :ebx :ecx)
		    (:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale down address
		    (,prefixes :movzxw (:ecx) :ecx)))))))))))

(defun memref-int (address offset index type &optional physicalp)
  (cond
   ((not physicalp)
    (ecase type
      (:lisp
       (memref-int address offset index :lisp))
      (:unsigned-byte8
       (memref-int address offset index :unsigned-byte8))
      (:unsigned-byte16
       (memref-int address offset index :unsigned-byte16))
      (:unsigned-byte32
       (memref-int address offset index :unsigned-byte32))))
   (physicalp
    (ecase type
      (:lisp
       (memref-int address offset index :lisp t))
      (:unsigned-byte8
       (memref-int address offset index :unsigned-byte8 t))
      (:unsigned-byte16
       (memref-int address offset index :unsigned-byte16 t))
      (:unsigned-byte32
       (memref-int address offset index :unsigned-byte32 t))))))

(define-compiler-macro (setf memref-int) (&whole form &environment env value address offset index type
					  &optional physicalp)
  (if (or (not (movitz:movitz-constantp type env))
	  (not (movitz:movitz-constantp physicalp env)))
      (progn
	(warn "setf memref-int form: ~S, ~S ~S" form type physicalp)
	form)
    (let* ((physicalp (movitz::eval-form physicalp env))
	   (prefixes (if (not physicalp)
			 ()
		       movitz:*compiler-physical-segment-prefix*)))
      (ecase type
	(:unsigned-byte32
	 (assert (= 4 movitz:+movitz-fixnum-factor+))
	 (if (not (movitz:movitz-constantp offset env))
	     form
	   (let ((offset (movitz:movitz-eval offset env))
		 (addr-var (gensym "memref-int-address-"))
		 (value-var (gensym "memref-int-value-")))
	     `(let ((,value-var ,value)
		    (,addr-var (+ ,address ,index)))
		(with-inline-assembly (:returns :untagged-fixnum-ecx)
		  (:compile-form (:result-mode :untagged-fixnum-ecx) ,addr-var)
		  (:testb ,(logior movitz:+movitz-fixnum-zmask+
				   (* 3 movitz:+movitz-fixnum-factor+))
			  :cl)
		  (:jnz '(:sub-program () (:int 70)))
		  (:shrl ,movitz:+movitz-fixnum-shift+ :ecx) ; a fixnum (zerop (mod x 4)) shifted
		  (:pushl :ecx)		; ..twice left is still a fixnum!
		  (:compile-form (:result-mode :untagged-fixnum-ecx) ,value-var)
		  (:popl :eax)
		  (:movl :ecx (:eax ,offset)))))))
	(:lisp
	 (assert (= 4 movitz:+movitz-fixnum-factor+))
	 `(with-inline-assembly (:returns :untagged-fixnum-eax)
	    (:compile-form (:result-mode :push) ,address)
	    (:compile-form (:result-mode :push) ,index)
	    (:compile-form (:result-mode :push) ,offset)
	    (:compile-form (:result-mode :eax) ,value)
	    (:popl :edx)		; offset
	    (:popl :ebx)		; index
	    (:popl :ecx)		; address
	    (:addl :edx :ecx)
	    (:shrl ,movitz::+movitz-fixnum-shift+ :ecx)
	    (,prefixes :movl :eax (:ecx :ebx))))
	(:unsigned-byte8
	 `(with-inline-assembly (:returns :untagged-fixnum-eax)
	    (:compile-form (:result-mode :push) ,address)
	    (:compile-form (:result-mode :push) ,index)
	    (:compile-form (:result-mode :push) ,offset)
	    (:compile-form (:result-mode :eax) ,value)
	    (:popl :edx)		; offset
	    (:popl :ebx)		; index
	    (:popl :ecx)		; address
	    (:shrl ,movitz::+movitz-fixnum-shift+ :eax)
	    (:addl :ebx :ecx)
	    (:addl :edx :ecx)
	    (:shrl ,movitz::+movitz-fixnum-shift+ :ecx)
	    (,prefixes :movb :al (:ecx))))
	(:unsigned-byte16
	 (cond
	  ((eq 0 offset)
	   (let ((address-var (gensym "memref-int-address-"))
		 (index-var (gensym "memref-index-var-"))
		 (value-var (gensym "memref-value-var-")))
	     `(let ((,value-var ,value)
		    (,address-var ,address)
		    (,index-var ,index))
		(with-inline-assembly (:returns :eax)
		  (:load-lexical (:lexical-binding ,value-var) :eax) ; value
		  (:load-lexical (:lexical-binding ,index-var) :ebx) ; index
		  (:load-lexical (:lexical-binding ,address-var) :ecx) ; address
		  (:shll 1 :ebx)	; scale index
		  (:addl :ebx :ecx)
		  (:shrl ,movitz:+movitz-fixnum-shift+ :ecx) ; scale address
		  (:std)
		  (:shrl ,movitz:+movitz-fixnum-shift+ :eax) ; scale value
		  (,prefixes :movw :ax (:ecx))
		  (:leal ((:eax ,movitz:+movitz-fixnum-factor+)) :eax)
		  (:cld)))))
	  (t (let ((address-var (gensym "memref-int-address-"))
		   (offset-var (gensym "memref-offset-var-"))
		   (index-var (gensym "memref-index-var-"))
		   (value-var (gensym "memref-value-var-")))
	       `(let ((,value-var ,value)
		      (,address-var ,address)
		      (,offset-var ,offset)
		      (,index-var ,index))
		  (with-inline-assembly (:returns :eax)
		    (:load-lexical (:lexical-binding ,address-var) :ecx)
		    (:load-lexical (:lexical-binding ,index-var) :ebx)
		    (:load-lexical (:lexical-binding ,offset-var) :edx)
		    (:load-lexical (:lexical-binding ,value-var) :eax)
		    (:leal (:ecx (:ebx 2)) :ecx)
		    (:addl :edx :ecx)	;
		    (:shrl ,movitz::+movitz-fixnum-shift+ :eax) ; scale value
		    (:std)
		    (:shrl ,movitz::+movitz-fixnum-shift+ :ecx) ; scale offset+address
		    (,prefixes :movw :ax (:ecx))
		    (:leal ((:eax ,movitz:+movitz-fixnum-factor+)) :eax)
		    (:cld)))))))))))

(defun (setf memref-int) (value address offset index type &optional physicalp)
  (cond
   ((not physicalp)
    (ecase type
      (:unsigned-byte8
       (setf (memref-int address offset index :unsigned-byte8) value))
      (:unsigned-byte16
       (setf (memref-int address offset index :unsigned-byte16) value))))
   (physicalp
    (ecase type
      (:unsigned-byte8
       (setf (memref-int address offset index :unsigned-byte8 t) value))
      (:unsigned-byte16
       (setf (memref-int address offset index :unsigned-byte16 t) value))))))

(defun memcopy (object-1 object-2 offset index-1 index-2 count type)
  (ecase type
    ((:unsigned-byte8 :character)
     (with-inline-assembly (:returns :nothing)
       (:compile-form (:result-mode :edx) offset)
       (:compile-form (:result-mode :ecx) index-1)
       (:addl :edx :ecx)
       (:compile-form (:result-mode :eax) object-1)
       (:sarl #.movitz::+movitz-fixnum-shift+ :ecx)
       (:addl :ecx :eax)

       (:compile-form (:result-mode :ecx) index-2)
       (:addl :edx :ecx)
       (:compile-form (:result-mode :ebx) object-2)
       (:sarl #.movitz::+movitz-fixnum-shift+ :ecx)
       (:addl :ecx :ebx)

       (:compile-form (:result-mode :ecx) count)
       (:shrl #.movitz::+movitz-fixnum-shift+ :ecx)
       (:jz 'done)
       (:decl :eax)
       (:decl :ebx)
       loop
       (:movb (:ebx :ecx) :dl)
       (:movb :dl (:eax :ecx))
       (:decl :ecx)
       (:jnz 'loop)
       done))))
	     
(define-compiler-macro %copy-words (destination source count &optional (start1 0) (start2 0)
				    &environment env)
  (assert (= 4 movitz::+movitz-fixnum-factor+))
  (cond
   ((and (movitz:movitz-constantp start1 env)
	 (movitz:movitz-constantp start2 env))
    (let ((start1 (movitz::eval-form start1 env))
	  (start2 (movitz::eval-form start2 env)))
      `(with-inline-assembly-case ()
	 (do-case (t :eax :labels (done copy-loop no-fixnum))
	   (:compile-arglist () ,destination ,source ,count)
	   (:popl :edx)			; count
	   ,@(unless (= 0 start1)
	       `((:addl ,(* start1 movitz::+movitz-fixnum-factor+) :eax)))
	   (:testl :edx :edx)
	   (:jz 'done)
	   ,@(unless (= 0 start2)
	       `((:addl ,(* start2 movitz::+movitz-fixnum-factor+) :ebx)))
	   (:testb ,movitz::+movitz-fixnum-zmask+ :dl)
	   (:jnz '(:sub-program ()
		   (:movl :edx :eax)
		   (:int 64)))
	  copy-loop
	   (:movl (:ebx :edx) :ecx)
	   (:movl :ecx (:eax :edx))
	   (:subl 4 :edx)
	   (:jnz 'copy-loop)
	  done))))
   (t `(with-inline-assembly-case ()
	 (do-case (t :eax :labels (done copy-loop no-fixnum))
	   (:compile-arglist () ,destination ,source ,count ,start1 ,start2)
	   (:popl :ecx)			; start2
	   (:addl :ecx :ebx)
	   (:popl :ecx)			; start1
	   (:addl :ecx :eax)
	   (:popl :edx)			; count
	   (:testl :edx :edx)
	   (:jz 'done)
	   (:testb ,movitz::+movitz-fixnum-zmask+ :dl)
	   (:jnz '(:sub-program ()
		   (:movl :edx :eax)
		   (:int 64)))
	  copy-loop
	   (:movl (:ebx :edx) :ecx)
	   (:movl :ecx (:eax :edx))
	   (:subl 4 :edx)
	   (:jnz 'copy-loop)
	  done)))))

(defun %copy-words (destination source count &optional (start1 0) (start2 0))
  (%copy-words destination source count start1 start2))
